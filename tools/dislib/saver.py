from __future__ import annotations

import struct
import sys

from typing import TYPE_CHECKING
from typing import (
    IO,
)

from dislib.miscdefs import (
    AT,
    LTYPECMD,
    LTYPESIZE,
)

if TYPE_CHECKING:
    from dislib.rom import Rom


class Saver:
    def __init__(self, *, rom: Rom, outfp: IO[str]) -> None:
        self.rom = rom
        self.outfp = outfp

    def save(self) -> None:
        self.write(f";; Autogenerated with the following command:\n")
        self.write(f";;    python3 {' '.join(map(repr, sys.argv[:]))}\n")
        self.write(f";; Do NOT hand-edit!\n")

        # Write memory map
        self.write(f"\n.MEMORYMAP\n")
        self.write(f"SLOT 0 START $0000 SIZE $4000\n")
        self.write(f"SLOT 1 START $4000 SIZE $4000\n")
        self.write(f"SLOT 2 START $8000 SIZE $4000\n")
        self.write(f"SLOT 3 START $C000 SIZE $2000\n")
        self.write(f"DEFAULTSLOT 2\n")
        self.write(f"DEFAULTRAMSECTIONSLOT 3\n")
        self.write(f".ENDME\n")

        # Write ROMBANKMAP
        self.write(f"\n.ROMBANKMAP\n")
        self.write(f"BANKSTOTAL 16\n")
        self.write(f"BANKSIZE $4000\n")
        self.write(f"BANKS 16\n")
        self.write(f".ENDRO\n")

        # Write special defines
        self.write(f"\n")
        self.write(f".DEF IYBASE $D200\n")

        # Write RAM addresses
        self.write(f'\n.RAMSECTION "RAMSection" SLOT 3 FORCE ORGA $C000\n')
        extra_ram_labels: list[str] = []
        prev_addr = 0xC000
        for addr in range(0xC000, 0xE000, 1):
            if addr in self.rom.labels_from_addr:
                base_label = self.rom.labels_from_addr[addr][0]
                if prev_addr != addr:
                    assert prev_addr < addr
                    self.write(f".  dsb {addr - prev_addr}\n")
                    prev_addr = addr
                if addr in self.rom.addr_types:
                    vartype = self.rom.addr_types[addr]
                    varsize = LTYPESIZE[vartype]
                    varcmd = LTYPECMD[vartype]
                    # Look for any labels in the middle of this.
                    need_split = False
                    for split_offs in range(1, varsize, 1):
                        if addr + split_offs in self.rom.labels_from_addr:
                            need_split = True
                            break
                    if need_split:
                        self.write(f"{base_label} db   ; {addr:04X} (split)\n")
                        prev_addr = addr + 1
                    else:
                        self.write(f"{base_label} {varcmd}   ; {addr:04X}\n")
                        prev_addr = addr + varsize
                else:
                    self.write(f"{base_label} db   ; {addr:04X} (auto)\n")
                    prev_addr = addr + 1
                for label in self.rom.labels_from_addr[addr][1:]:
                    extra_ram_labels.append(f".DEF {label} {base_label}\n")
        self.write(f".ENDS\n")
        for s in extra_ram_labels:
            self.write(s)

        # Write extra addresses
        self.write(f"\n")
        for addr in range(0xE000, 0x10000, 1):
            for label in self.rom.labels_from_addr.get(addr, []):
                self.write(f".DEF {label} ${addr:04X}\n")

        # Write ROM
        for bank_idx in range(16):
            # Assume all banks past the first 2 want to be in slot 2
            slot_idx = min(2, bank_idx)
            self.write(
                f'\n.SECTION "Bank{bank_idx:02X}" SLOT {slot_idx} BANK ${bank_idx:02X} FORCE ORG $0000\n'
            )
            bank = self.rom.data[bank_idx * self.rom.bank_size :][: self.rom.bank_size]

            prev_rel_addr = 0
            for rel_addr in range(self.rom.bank_size):
                phys_addr = rel_addr + (bank_idx * self.rom.bank_size)
                virt_addr = rel_addr + (slot_idx * self.rom.bank_size)
                if phys_addr < 0xC000 and phys_addr in self.rom.labels_from_addr:
                    if prev_rel_addr != rel_addr:
                        self.save_bytes(
                            bank_idx=bank_idx,
                            phys_addr=(bank_idx * self.rom.bank_size) + prev_rel_addr,
                            virt_addr=(slot_idx * self.rom.bank_size) + prev_rel_addr,
                            data=bank[prev_rel_addr:rel_addr],
                        )
                        prev_rel_addr = rel_addr
                    self.write(f"\n")
                    for label in self.rom.labels_from_addr[phys_addr]:
                        self.write(f"{label}:\n")

            self.save_bytes(
                bank_idx=bank_idx,
                phys_addr=(bank_idx * self.rom.bank_size) + prev_rel_addr,
                virt_addr=(slot_idx * self.rom.bank_size) + prev_rel_addr,
                data=bank[prev_rel_addr:],
            )

            self.write(f".ENDS\n")

    def save_bytes(
        self,
        *,
        bank_idx: int,
        phys_addr: int,
        virt_addr: int,
        data: bytes,
    ) -> None:
        offs = 0
        prev_subregion_offs = 0
        prev_subregion_type = AT.DataByte
        while offs < len(data):
            op_phys_addr = phys_addr + offs
            ltype = self.rom.addr_types.get(op_phys_addr, AT.DataByte)
            if op_phys_addr >= 0xC000:
                # FIXME: Actually handle bank memory mapping properly,
                # this works around an issue where Bank03 gets weirdly sliced based on RAM labels --GM
                ltype = AT.DataByte

            if ltype == AT.Op:
                try:
                    op_len, op_str = self.rom.op_decodes[op_phys_addr]
                except LookupError:
                    self.write(f"   ;; FIXME: Undecoded op!\n")
                    ltype = AT.DataByte
                else:
                    if offs + op_len > len(data):
                        # Decode as if it wasn't an op
                        self.write(f"   ;; FIXME: Label appears mid-op!\n")
                        ltype = AT.DataByte
                        # Carry on!
                    else:
                        if offs != prev_subregion_offs and ltype != prev_subregion_type:
                            self.save_subregion(
                                bank_idx=bank_idx,
                                virt_addr=virt_addr + prev_subregion_offs,
                                data=data[prev_subregion_offs:offs],
                                atype=prev_subregion_type,
                            )
                            prev_subregion_offs = offs

                        prev_subregion_type = ltype

                        assert op_len >= 1
                        op_hex = " ".join(
                            f"{v:02X}" for v in data[offs : offs + op_len]
                        )
                        self.write(
                            f"   {op_str}{' '*max(0, 34-len(op_str))}  ; {bank_idx:02X}:{virt_addr + offs:04X} - {op_hex}\n"
                        )
                        offs += op_len
                        prev_subregion_offs = offs
                        continue

            if ltype == AT.DataByteRelLabel:
                ltype = AT.DataByte

            if ltype == AT.DataWord or ltype == AT.DataWordLabel:
                if offs != prev_subregion_offs and ltype != prev_subregion_type:
                    self.save_subregion(
                        bank_idx=bank_idx,
                        virt_addr=virt_addr + prev_subregion_offs,
                        data=data[prev_subregion_offs:offs],
                        atype=prev_subregion_type,
                    )
                    prev_subregion_offs = offs

                prev_subregion_type = ltype

                offs += 2

            elif ltype == AT.DataByte:
                if offs != prev_subregion_offs and ltype != prev_subregion_type:
                    self.save_subregion(
                        bank_idx=bank_idx,
                        virt_addr=virt_addr + prev_subregion_offs,
                        data=data[prev_subregion_offs:offs],
                        atype=prev_subregion_type,
                    )
                    prev_subregion_offs = offs

                prev_subregion_type = ltype

                offs += 1

            else:
                raise Exception(f"unimplemented region save type {ltype}")

        if offs != prev_subregion_offs:
            self.save_subregion(
                bank_idx=bank_idx,
                virt_addr=virt_addr + prev_subregion_offs,
                data=data[prev_subregion_offs:offs],
                atype=prev_subregion_type,
            )

    def save_subregion(
        self,
        *,
        bank_idx: int,
        virt_addr: int,
        data: bytes,
        atype: AT,
    ) -> None:
        if atype == AT.DataByte:
            for row_idx in range((len(data) + 16 - 1) // 16):
                row_addr = row_idx * 16
                row_data = data[row_addr : row_addr + 16]
                row = ", ".join(f"${v:02X}" for v in row_data)
                row += " " * ((len(", $xx") * 16 - len(", ")) - len(row))
                self.write(f".db {row}  ; {bank_idx:02d}:{virt_addr+row_addr:04X}\n")

        elif atype == AT.DataWord or atype == AT.DataWordLabel:
            for row_idx in range((len(data) + 16 - 1) // 16):
                row_addr = row_idx * 16
                row_size = min(row_addr + 16, len(data)) - row_addr
                row_vals = [
                    struct.unpack("<H", data[row_addr + bi * 2 :][:2])[0]
                    for bi in range(row_size // 2)
                ]
                if len(row_vals) >= 1:
                    if atype == AT.DataWordLabel:
                        print(f"{virt_addr:05X} {bank_idx:02X} {row_size:3d}")
                        row_strs = [
                            self.rom.labels_from_addr.get(v, [f"${v:04X}"])[0]
                            for v in row_vals
                        ]
                    else:
                        row_strs = [f"${v:04X}" for v in row_vals]
                    row = ", ".join(row_strs)
                    row += " " * ((len(", $xx") * 16 - len(", ")) - len(row))
                    self.write(
                        f".dw {row}  ; {bank_idx:02d}:{virt_addr+row_addr:04X}\n"
                    )

                row_remain = row_size % 2
                if row_remain != 0:
                    self.write(f"   ;; FIXME: Word table not a multiple of 2!\n")
                    self.save_subregion(
                        bank_idx=bank_idx,
                        virt_addr=virt_addr + row_addr + row_size - row_remain,
                        data=data[row_addr + row_size - row_remain :][:row_remain],
                        atype=AT.DataByte,
                    )

        else:
            raise Exception(f"unimplemented subregion save type {atype}")

    def write(self, s: str) -> None:
        self.outfp.write(s)
